package org.campagnelab.bdval.behavior;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import java.io.File;
import javax.swing.JOptionPane;
import org.apache.commons.io.FileUtils;
import java.util.Properties;
import java.io.OutputStream;
import java.io.FileOutputStream;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import javax.swing.JFrame;
import java.awt.BorderLayout;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JProgressBar;
import javax.swing.JPanel;
import javax.swing.BorderFactory;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import org.apache.tools.ant.Project;
import java.io.PrintStream;
import org.apache.tools.ant.DefaultLogger;
import org.apache.tools.ant.ProjectHelper;
import java.io.BufferedReader;
import java.io.FileReader;

public class Project_Behavior {
  public static void init(SNode thisNode) {
  }

  public static boolean call_checkProjectFolder_3976565827571671486(SNode thisNode) {
    String projectName = SPropertyOperations.getString(thisNode, "name").replaceAll("\\s", "");
    String directoryName = SPropertyOperations.getString(SLinkOperations.getTarget(thisNode, "properties", true), "outputLocation") + "/" + ((projectName == null ? null : projectName.trim())) + "/";
    boolean proceed;
    File directoryFile = new File(directoryName);
    if (directoryFile.exists()) {
      int reply = JOptionPane.showConfirmDialog(null, directoryName + " already exists. Delete Folder and Continue?", "Directory exists", JOptionPane.YES_NO_CANCEL_OPTION);
      switch (reply) {
        case JOptionPane.YES_OPTION:
          try {
            FileUtils.deleteDirectory(directoryFile);
          } catch (Exception e) {
            throw new Error("Error deleting existing Project Folder");
          }
          proceed = true;
          break;
        default:
          proceed = false;
      }
    } else {
      proceed = true;
    }
    return proceed;
  }

  public static void call_createFiles_290469645456423260(SNode thisNode) {
    String projectName = SPropertyOperations.getString(thisNode, "name").replaceAll("\\s", "");
    Project_Behavior.call_createLocalProperties_7083662764418572584(thisNode, projectName);
    Project_Behavior.call_createProperties_290469645499580654(thisNode, projectName);
  }

  public static void call_createLocalProperties_7083662764418572584(SNode thisNode, String projectName) {
    String fileName = SPropertyOperations.getString(SLinkOperations.getTarget(thisNode, "properties", true), "outputLocation") + "/" + projectName + "/" + projectName + "-local.properties";
    try {
      Properties prop = new Properties();
      OutputStream output = new FileOutputStream(new File(fileName));
      prop.setProperty("eval-dataset-root", SPropertyOperations.getString(SLinkOperations.getTarget(thisNode, "properties", true), "outputLocation") + "/" + SPropertyOperations.getString(thisNode, "name").replaceAll("\\s", ""));
      String computerType = SPropertyOperations.getString(SLinkOperations.getTarget(SLinkOperations.getTarget(thisNode, "properties", true), "computerType", true), "name");
      prop.setProperty("computer.type", computerType);
      if (computerType.matches("server")) {
        prop.setProperty("server.thread-number", "" + SPropertyOperations.getInteger(SLinkOperations.getTarget(thisNode, "properties", true), "threads"));
        prop.setProperty("server.memory", "-Xmx" + SPropertyOperations.getInteger(SLinkOperations.getTarget(thisNode, "properties", true), "memory") + "m");
      } else {
        prop.setProperty("desktop.thread-number", "" + SPropertyOperations.getInteger(SLinkOperations.getTarget(thisNode, "properties", true), "threads"));
        prop.setProperty("desktop.memory", "-Xmx" + SPropertyOperations.getInteger(SLinkOperations.getTarget(thisNode, "properties", true), "memory") + "m");
      }
      prop.store(output, SPropertyOperations.getString(thisNode, "name") + " Local Properties");
    } catch (Exception e) {
      throw new Error("Error creating local properties file");
    }
  }

  public static void call_createProperties_290469645499580654(final SNode thisNode, final String projectName) {
    String fileName = SPropertyOperations.getString(SLinkOperations.getTarget(thisNode, "properties", true), "outputLocation") + "/" + projectName + "/" + projectName + ".properties";
    try {
      final Properties prop = new Properties();
      OutputStream output = new FileOutputStream(new File(fileName));
      final Wrappers._T<String> datasetName = new Wrappers._T<String>();
      final String root = "${eval-dataset-root}";
      ListSequence.fromList(SLinkOperations.getTargets(thisNode, "dataset", true)).visitAll(new IVisitor<SNode>() {
        public void visit(final SNode dataset) {
          datasetName.value = DataSet_Behavior.call_getName_290469645480322571(dataset);
          prop.setProperty(datasetName.value + ".dataset-name", projectName);
          prop.setProperty(datasetName.value + ".dataset-file", root + "/inputs/" + new File(SPropertyOperations.getString(SLinkOperations.getTarget(dataset, "input", true), "fileName")).getName());
          prop.setProperty(datasetName.value + ".cids-file", root + "/cids/" + datasetName.value + ".cids");
          prop.setProperty(datasetName.value + ".tasks-file", root + "/tasks/" + datasetName.value + ".tasks");
          // TODO: Fill in floor 
          prop.setProperty(datasetName.value + "floor", "");
          if (SPropertyOperations.getBoolean(dataset, "normalTarget")) {
            final Wrappers._T<String> nonTargetName = new Wrappers._T<String>();
            ListSequence.fromList(SLinkOperations.getTargets(thisNode, "dataset", true)).visitAll(new IVisitor<SNode>() {
              public void visit(SNode nonTarget) {
                if (SPropertyOperations.getBoolean(nonTarget, "testSet")) {
                  nonTargetName.value = datasetName.value + "." + SPropertyOperations.getString(nonTarget, "name").replaceAll("\\s", "").toLowerCase();
                  prop.setProperty(nonTargetName.value + ".test-samples", root + "/test-sets/" + DataSet_Behavior.call_getName_290469645480322571(nonTarget) + "-samples.txt");
                  prop.setProperty(nonTargetName.value + ".true-labels", root + "/cids/" + DataSet_Behavior.call_getName_290469645480322571(nonTarget) + ".cids");
                  if (!(SPropertyOperations.getString(SLinkOperations.getTarget(nonTarget, "input", true), "fileName").matches(SPropertyOperations.getString(SLinkOperations.getTarget(dataset, "input", true), "fileName")))) {
                    prop.setProperty(nonTargetName.value + ".dataset-file", root + "/inputs/" + new File(SPropertyOperations.getString(SLinkOperations.getTarget(nonTarget, "input", true), "fileName")).getName());
                  }
                }
              }
            });
          }
          prop.setProperty(datasetName.value + ".platform-file", root + "/platforms/" + new File(SPropertyOperations.getString(SLinkOperations.getTarget(dataset, "platform", true), "fileName")).getName());
          if (isNotEmptyString(SPropertyOperations.getString(SLinkOperations.getTarget(dataset, "otherFiles", true), "pathways"))) {
            prop.setProperty(datasetName.value + ".pathways-file", root + "/pathways/" + new File(SPropertyOperations.getString(SLinkOperations.getTarget(dataset, "otherFiles", true), "pathways")).getName());
            prop.setProperty(datasetName.value + ".gene-to-probes-file", root + "/pathways/" + new File(SPropertyOperations.getString(SLinkOperations.getTarget(dataset, "otherFiles", true), "geneToProbes")).getName());
          }
          if (isNotEmptyString(SPropertyOperations.getString(SLinkOperations.getTarget(dataset, "otherFiles", true), "survival"))) {
            prop.setProperty(datasetName.value + ".survival-file", root + "/survivals/" + new File(SPropertyOperations.getString(SLinkOperations.getTarget(dataset, "otherFiles", true), "survival")).getName());
          }
        }
      });
      // Finish bottom: custom ID/model 
      prop.store(output, SPropertyOperations.getString(thisNode, "name") + " Properties");
    } catch (Exception e) {
      throw new Error("Error creating properties file");
    }
  }

  public static void call_createRunWindow_6752420586317975318(SNode thisNode) {
    JFrame frame = new JFrame("BDVal " + SPropertyOperations.getString(thisNode, "name") + " Project");
    frame.setLayout(new BorderLayout());
    frame.setSize(500, 90);

    final JButton runButton = new JButton("Run");
    final JLabel label = new JLabel();
    final JProgressBar progressBar = new JProgressBar();

    JPanel panel = new JPanel(new BorderLayout());
    panel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
    panel.add(runButton, BorderLayout.WEST);
    panel.add(label, BorderLayout.EAST);
    panel.add(progressBar, BorderLayout.SOUTH);

    frame.setContentPane(panel);
    frame.setLocationRelativeTo(null);
    frame.setVisible(true);

    progressBar.setValue(0);
    progressBar.setStringPainted(true);

    final int numModels = Project_Behavior.call_getNumModels_7860773100992528077(thisNode) + 1;

    final SNode project = thisNode;
    final String folder = SPropertyOperations.getString(SLinkOperations.getTarget(thisNode, "properties", true), "outputLocation") + "/" + SPropertyOperations.getString(thisNode, "name").replaceAll("\\s", "").trim() + "/";
    final String name = SPropertyOperations.getString(thisNode, "name").replaceAll("\\s", "").trim();
    runButton.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        runButton.setEnabled(false);
        new File(folder + "messages.txt");
        Thread antCall = new Thread() {
          public void run() {
            Project p = new Project();
            try {
              File messages = new File(folder + "messages.txt");
              PrintStream printStream = new PrintStream(messages);
              File buildFile = new File(folder + name + ".xml");
              p.setUserProperty("ant.file", buildFile.getAbsolutePath());
              DefaultLogger consoleLogger = new DefaultLogger();
              consoleLogger.setErrorPrintStream(System.err);
              consoleLogger.setOutputPrintStream(printStream);
              consoleLogger.setMessageOutputLevel(Project.MSG_INFO);
              p.addBuildListener(consoleLogger);
              p.fireBuildStarted();
              p.init();
              ProjectHelper helper = ProjectHelper.getProjectHelper();
              p.addReference("ant.projectHelper", helper);
              helper.parse(p, buildFile);
              p.executeTarget(p.getDefaultTarget());
              p.fireBuildFinished(null);
            } catch (Exception e) {
              p.fireBuildFinished(e);
              throw new Error("Error running ant");
            }
          }
        };
        antCall.start();
        Thread monitorProgress = new Thread() {
          public void run() {
            boolean stop = false;
            String line = "";
            int counter = 0;
            try {
              BufferedReader br = new BufferedReader(new FileReader(folder + "messages.txt"));
              label.setText("Initializing");
              while (!(stop)) {
                line = br.readLine();
                if (line == null) {
                  Thread.sleep(1000);
                } else {
                  if (line.contains("execute-splits ->") || line.contains("Item:-m predict")) {
                    counter++;
                    progressBar.setValue((counter * 100) / numModels);
                    if (counter < numModels) {
                      label.setText("Processing " + counter + " of " + (numModels - 1));
                    }
                  }
                  stop = line.contains("Total time:");
                }
              }
              progressBar.setValue(100);
              label.setText("Done!");
            } catch (Exception e) {
              throw new Error("Error monitoring progress");
            }
          }
        };
        monitorProgress.start();
      }
    });
  }

  public static int call_getNumModels_7860773100992528077(SNode thisNode) {
    final SNode approach = SLinkOperations.getTarget(thisNode, "approach", true);
    final Wrappers._int classificationsNum = new Wrappers._int(0);
    ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(approach, "classificationInfo", true), "classification", true)).visitAll(new IVisitor<SNode>() {
      public void visit(SNode classification) {
        if (SPropertyOperations.getString(classification, "name").matches("SVMTuneC")) {
          classificationsNum.value = classificationsNum.value + ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(approach, "classificationInfo", true), "classificationProperties", true), "svmTuneCProperties", true), "cValue", true)).count();
        } else {
          classificationsNum.value++;
        }
      }
    });
    final int foldNum = ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(approach, "featureSelectionInfo", true), "featureSelectionFold", true)).count();
    final Wrappers._int featureSelectionNum = new Wrappers._int(0);
    ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(approach, "featureSelectionInfo", true), "featureSelectionCombo", true)).visitAll(new IVisitor<SNode>() {
      public void visit(SNode featureSelectionCombo) {
        if (SPropertyOperations.getString(SLinkOperations.getTarget(featureSelectionCombo, "featureSelection1", true), "name").matches("wholeChip")) {
          featureSelectionNum.value++;
        } else {
          featureSelectionNum.value = featureSelectionNum.value + foldNum;
        }
      }
    });
    return featureSelectionNum.value * classificationsNum.value * ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(approach, "featureSelectionInfo", true), "numberOfFeatures", true)).count() * SPropertyOperations.getInteger(approach, "externalFolds") * SPropertyOperations.getInteger(approach, "externalRepeats");
  }

  private static boolean isNotEmptyString(String str) {
    return str != null && str.length() > 0;
  }
}
